# 今日の豆知識.9

今日はポインタと値渡し/参照渡しについてです。

ポインタを理解するために軽くプログラミング言語の仕組みについて説明します。ここではわかりやすいようにRustで書きます。(letや型注釈があるから)

例えば
```rust
let x : i32 = 10;
```
みたいなコードでは
> `x`という変数を`i32`(32bitの整数型)で宣言して`x`に`10`を代入している
のように説明されることが多いです。
ではここでの**宣言**や**代入**って何なのでしょうか?
端的に言うと
- 宣言とはメモリ上のアドレスと変数名を結びつけること(メモリ領域を割り当てると言うことも)
- 代入とは変数と結びつけられたメモリ上のアドレスに値を書き込むこと
です。

ここでメモリ上のアドレスと言っていますが,メモリでは1byte(8bit)ごとに住所のように整数値が割り当てられています。また,この数値を値として保持している**変数**や一時的に保持する**レジスタ**のことを**ポインタ**と呼びます。
難しく聞こえるかもしれませんが簡単に言うと
```
addr = 山梨県_南都留郡....
```
のようにしたときの`addr`のことを`山梨県_南都留郡....`を指す**ポインタ**と呼ぶということです。

最初の例では
`x`という変数名に対して内部でメモリ上のアドレスが結び付けられて,以降`x`が使われるときは結び付けられたメモリ上のアドレスのところに記録されている値を読み取るようになります。

中間言語を見るとわかりやすいと思います。
Rustで
```rust
let x : i32 = 10;
let y : i32 = x;
```
みたいに書いたとします。これは以下のような中間言語になります。
```llvm
  %x = alloca i32, align 4
  store i32 10, ptr %x, align 4
  %x1 = load i32, ptr %x, align 4
  %y = alloca i32, align 4
　store i32 %x1, ptr %y, align 4
```
(align 4っていうのはi32が32bit つまり4byteであるためついているもで,今は一旦無視してください)

1行目では`alloca i32`で`i32`っていう型でメモリ上の領域を確保(ここは使用済みですよ～って言うようなもん)して,その領域のアドレスを`%x`に保存しています。ここで`%x`は`alloca i32`で確保された領域を指す**ポインタ**であるといえ,　また,同時にこのアドレスがRustでの変数`x`という名前にコンパイラ(ここではとりあえずRustから中間言語に変換するものという認識で大丈夫です)内部で結び付けられているため,`x`のアドレスを指す**ポインタ**とも言えます。
ちなみに,`i32`という型は値を保持するのに4byte必要なため`alloca i32`では4byte分の連続した領域を確保して,`%x`にはその先頭のアドレスが渡されています。

2行目では`store i32 10, ptr %x`というのはポインタ`%x`が指すアドレスに`i32`という型の`10`という値を書き込むということをしています。
> (ptrというのはポインタ型であることを意味している(pointerの略としてptrと書くことがよくある,integerをintって略すようなもん)。より正確に言うと`%x`自体もアドレスを値として保持する変数のようなものなので,`ptr %x`は`i32 10`が`10`を`i32`という型として解釈するということを意味しているように`%x`を`ptr`という型として解釈するということを意味している)

3行目では`%x`が指すアドレスに記録されてる値を`i32`という型として読み込んでその値を`%x1`に記録している。ここで`%x1`は`10`である。

4行目では1行目と同様に`alloca i32`で`i32`っていう型でメモリ上の領域を確保してそのアドレスを`%y`に保存

5行目では2行目同様にポインタ`%y`が指すアドレスに`i32`という型で`%x1`の値(つまり10)を書き込むということをしています

ではここで以前Pythonの`=`についてでの説明で出てきた**値渡し**/**広義の参照渡し**/**狭義の参照渡し**について説明しようと思います。

その前にこの先説明でC/C++を使うので重要な文法について軽く説明します。
```c
int x = 10; // Rustのlet mut x : i32 = 10;に相当する(mutについては以前どこかで軽く説明してあると思うので説明は省略)
int* ptr_of_x = &x; // &xのように&をつけることでxの値が保持されているアドレスを指すポインタを意味する。またこれをxの参照と呼ぶこともある。int*はint型の値があるアドレスを指すポインタ型のことを意味する
int y = *ptr_of_x; // *ptr_of_xのように*をつけることでそのポインタが指すアドレスに保持されている値を意味する。ここではptr_of_xの型はint*なのでint型として読まれる。このようにポインタからそのアドレスが指すアドレスに保持されている値を得ることをデリファレンスや参照外しと呼ぶ

int z = 5;
z = 8; // zの値が保持されているアドレスに8という値を上書き
```

では本題に戻ります。

**値渡し**とは上の
```c
int x = 10;
int y = *ptr_of_x;
```
や
```c
z = 8;
```
のようにポインタではなく名前通り値を渡すことです。
この時,`x`や`z`のアドレスは右辺の影響を受けません
そのため
```c
int a = 1;
int b = a; // これも値渡し
```
としたときに`&a != &b`となっています。(!= は not equal)

**広義の参照渡し**(参照の値渡し)とは上の
```c
int* ptr_of_x = &x;
```
のようなものです。これは`ptr_of_x`は`x`の値があるアドレスを値として持っているため
```c
*ptr_of_x = 100;
```
みたいにすることで`x`の値も`100`に書き変えることができます。つまり,`*ptr_of_x`のようにデリファレンスしたものと`x`は完全に同等(値が記録されているメモリ上のアドレスまで一致している。つまり`&*ptr_of_x == &x`)です。
しかし,これは狭義の参照渡しとは異なります。というのも,`int* ptr_of_x = &x;`では`&x`という**参照**という**値**が渡されていると解釈ができるからです。

**狭義の参照渡し**とは広義の参照渡しでの`*ptr_of_x`と`x`のような関係をポインタを介さずに作る。つまり別名(alias)を作ることです。
C言語やRustではこの機能は存在せず(というかC/Rustに限らず多くの言語では存在しない)、C++やFortranやPascalのような一部の言語にのみ存在するものです。
C++では
```cpp
int x = 10;
int& y = x;
```
のようにすることで`x`と完全に同等な`y`をポインタを介せずに作ることができます。これが狭義の参照渡しです。

ちなみに狭義の参照渡しが多くの言語で実装されていない理由としては
- 影響の出る範囲がわかりにくい
- UBが多くなる
- 最適化が効きにくい
- SSA(Static Single Assignment form)が崩れる
- 広義の参照渡しで安全な代替が実現できる (Rustの所有権/借用やSwiftのinoutやC#のref)
- 学習コストが高くなる
などなどが挙げられる。機能は多ければいいというものでもない

現在はよくないと言われることが多い狭義の参照渡しですが,C++が作られた当時としては,危険とは言えど,C言語との互換性を維持しつつなんでもできてしまうさらに危険なC言語のポインタを使わなくてよいようにできたり,並行処理があまり使われていなかったり,問題点がそこまで認識されていなかったりと,合理的なものだったのです。