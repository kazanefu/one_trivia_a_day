# 今日の豆知識.16

今日は遅延評価(lazy evaluation)についてです。

簡単に言うと遅延評価とは、値が必要になったときに初めて評価するという意味です。つまり、値が必要になるまで評価を遅らせることを意味します。

遅延評価は正格評価(即時評価)と対照的に呼ばれます。

以下のように比較されることが多いです。

| 観点      | 遅延評価       | 正格評価   |
| ------- | ---------- | ------ |
| 計算タイミング | 必要になるまで    | すぐ     |
| 無限構造    | 可能         | 不可     |
| パフォーマンス | 良い場合も悪い場合も | 予測しやすい |
| デバッグ    | 難しい        | 簡単     |
| 副作用     | 扱いづらい      | 扱いやすい  |
| 実装      | 複雑         | 単純     |

では実際のコードで比較してみましょう。一応わかりやすくするために型注釈もつけておきます。

正格評価
```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
fn main() {
    let x:i32 = add(1, 2); // この時点で計算されて x = 3になっている
    println!("{}", x); // 3
}
```
遅延評価
```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
fn main() {
    let x:Fn() -> i32 = ||add(1,2); // この時点で計算されていない x = 1 + 2のまま
    println!("{}", x()); // 3 ここで初めて計算されて x() = 3
}
```
正格評価では`x`は最初から`i32`型の`3`という値になっているのに対して遅延評価では`x`は最初から`Fn() -> i32`型(引数なし戻り値i32の関数型)の`add(1,2)`という式のままになっています。

どうでしょう大体わかりましたか?

ここで一応Rustの文法を説明しておくと
```rust
let f = |x:i32| x + 1;
```
のようにしたとき`f`という関数を作ることができ,これは`f(x)`のように呼び,引数が`x`で戻り値が`x + 1`という関数になります。関数の中で複数の処理をしたいときとかは`{}`の中に書くことができます。
```rust
let f = |x:i32| {
    let y = x + 1;
    y
};
```
のように書くことができます。

**本題に戻ります。**

では遅延評価のメリットは何でしょうか?

1. 不要な計算をしなくて済む
2. 無限データ構造が扱える
3. 宣言的・合成的なコードが書ける
4. モジュール性・再利用性が高い

それぞれについて軽く見ていきましょう

1についてはWapLでわかりやすい例があるのでそれを見てみましょう。WapLには標準で`?()`と`choose()`という非常に似た関数が用意されています。両方とも第1引数に`bool`型で条件式を受け取り,`true`の場合は第2引数を返し,`false`の場合は第3引数を返すという動作をします。
例えば
```wapl
#=(x, ?(true, 3, 5), i64); // x = 3
#=(y, ?(false, 3, 5), i64); // y = 5
#=(z, choose(true, 3, 5), i64); // z = 3
#=(w, choose(false, 3, 5), i64); // w = 5
```
`?()`と`choose()`の違いは`?()`は遅延評価で`choose()`は正格評価であることです。
```wapl
use "./std/utility.wapl"

fn l_eval():i32{
    println("Left: evaluated!");
    return 1s;
}
fn r_eval():i32{
    println("Right: evaluated!");
    return 0s;
}
fn main():i32{
    printf("%d\n",choose(true,l_eval(),r_eval())); // chooseによる正格評価
    return 0s;
}
```
このようにしたとき
```
Left: evaluated!
Right: evaluated!
1
```
となるように正格評価では両方の引数の計算をしています。`true`なのだから`r_eval()`を評価する必要はないのに評価してしまっているのです。

一方`?()`は遅延評価なので
```wapl
use "./std/utility.wapl"

fn l_eval():i32{
    println("Left: evaluated!");
    return 1s;
}
fn r_eval():i32{
    println("Right: evaluated!");
    return 0s;
}
fn main():i32{
    printf("%d\n",?(true,l_eval(),r_eval())); // ?による遅延評価
    return 0s;
}
```
```
Left: evaluated!
1
```
となります。ここでは先ほど評価されていた`r_eval()`を評価しないで済んでいます。

このように遅延評価によって無駄な計算を避けられるのです。

2については例えばフィボナッチ数列を考えてみましょう。フィボナッチ数列には上限はなく,無限に続きますが,コンピュータのメモリには上限があるため無限のサイズの配列を持つことはできません。そのようなときにはフィボナッチ数列を配列ではなく**漸化式**の形で表現して,遅延評価によって必要なときにだけ計算をするようにすれば無限のフィボナッチ数列を扱えます。
Rustでは
```rust
// フィボナッチ数列
fn fibs() -> impl Iterator<Item = u128> {
    // 漸化式のイテレータで初項は(0,1)で(a_n, a_n+1) -> (a_n+1, a_n + a_n+1 = a_n+2)のフィボナッチ数列の漸化式
    // 2項セットにしているので返すときは.map(|(a,_)|a)で片方だけにしている
    std::iter::successors(Some((0_u128, 1_u128)), |(a, b)| Some((*b, a + b))).map(|(a, _)| a)
}

fn main() {
    let n = 80;
    let m = 100;
    println!(
        "fibonacci[n..=m] = {:?}",
        fibs().skip(n).take(m - n + 1).collect::<Vec<u128>>()
    ); // collectでVec<u128>にされるときにはじめて評価される遅延評価
}
```
ちなみにRustのイテレータチェーン(こんな感じにイテレータにメソッドをつなげていくやつ)は基本的に遅延評価で,`next()`が呼び出されたときにはじめて評価されます。ここでは`collect`が内部で`next()`を呼び出しているためそこで初めて評価されます。

Haskellでは
```haskell
import Data.List (intercalate)

-- 無限フィボナッチ数列の漸化式（遅延評価）
{-
fibs = [0,1,1,2,3,5,...]と
drop 1 fibs = [1,1,2,3,5,...]を
zipWith (+)で各要素を足し合わせたものを[0,1]の最後に追加
つまり
[0,1]<-[1,2,3,5,8,...] = [0,1,1,2,3,5,8,...]
-}
fibs :: [Integer]
fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)

-- n..=m 番目を ',' 区切りで表示
showFibs :: Int -> Int -> String
showFibs n m =
  intercalate "," $
  map show $
  take (m - n + 1) $
  drop n fibs

main :: IO ()
main = do
  let n = 80
  let m = 100
  putStrLn $ showFibs n m -- ここで初めて評価
```

3,4についてもフィボナッチ数列の例から分かるように**こういう漸化式のもの**っていう感じで**宣言的**に書くことができ,さらにそれをつなげることで関数の合成みたいなことができ,また,そのためモジュール性も高いです。

ここで**宣言的**に書くと言いましたが,これは,どういう処理をするのかではなく何が欲しいのかを書くということです。この辺は一応イテレータのとこで軽く解説してると思うので読み返してみてください。ここで追加で説明することとしては宣言的に書くことで中間状態が意味的に消えてより問題の本質に注目できるということです。数学で言うと`f(g(x))`としたとき一旦`y = g(x)`とでもして`f(y)`という中間状態を考えるのではなく`f∘g(x)`のように合成関数を書くようなものです。
