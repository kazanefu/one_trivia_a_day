# 今日の豆知識.13

今日はオブジェクト指向プログラミング(Object Oriented Programming以降OOP)についての前半です。今回はかつてOOPがどのような方法でどのような問題を解決したのかについて説明し, 次回はOOPの問題点と現代のOOPはかつてのからどのように変化したのか,また, 他のパラダイム(OOP以前からある手続き型や最近話題の関数型や現代最も使われているであろうマルチパラダイムの言語など)についても軽くせつめいします。

OOPを一言で説明するなら"**状態を持つモノ(Object)中心で記述するプログラミングパラダイム**"

オブジェクトとは何か? -> データ + ふるまい(メソッド)

OOPが解決しようとした問題

1. 大規模化によるコードの把握困難(スパゲッティコードの発生)
    - プログラムが大きくなると、どこでどのデータが書き換えられたか追跡できなくなり、修正が別の場所に予期せぬ影響が出る
2. データと処理の乖離
    - 同じデータ構造を複数の関数が勝手に操作できてしまう
3. 再利用の難しさ
    - 似たような機能を作るときも、コードをコピー＆ペーストして一部を書き換えるしかなく、修正が必要な際に関係箇所すべてを直す手間や修正忘れの可能性
4. 現実世界との乖離
    - 現実の概念が,コード上ではただの変数と関数の集まりになり,直感的に理解しにくかった

これに対するOOPのアプローチ

- **カプセル化**: データとそれを操作する関数（メソッド）を一つにまとめ、外部から直接触らせない。
- **継承**: 既存のクラスの機能を引き継いで、新しいクラスを作る。
- **ポリモーフィズム**: 異なるオブジェクトに対して、同じ名前のメソッドで異なる振る舞いをさせる。

とりあえずC\#でOOPを使って書いたコードを見てみましょう

このプログラムはペンを使って入力した文字を色付きや斜体で出力するものです。
```cs
using System;
using System.Collections.Generic;

// ペンの抽象クラス
abstract class Pen
{
    public abstract void Write(string input);
}
// ペンを継承してボールペンクラスを作る
class BallPen : Pen
{
    public required Ink ink;
    public override void Write(string input)
    {
        Console.WriteLine(ink.Color + input + "\u001b[0m"); // inkの色で出力
    }
}
// ペンを継承して万年筆クラスを作る
class FountainPen : Pen
{
    public required Ink ink;
    public override void Write(string input)
    {
        Console.WriteLine(ink.Color + "\u001b[3m" + input + "\u001b[23m" + "\u001b[0m"); // inkの色で斜体で出力
    }
}
// インクの抽象クラス
abstract class Ink
{
    abstract public string Color { get; }
}
// インクを継承して赤インククラスを作る
class RedInk : Ink
{
    string color = "\x1b[31m"; // 赤色
    public override string Color
    {
        get { return color; }
    }
}
// インクを継承して青インククラスを作る
class BlueInk : Ink
{
    string color = "\u001b[34m"; // 青色
    public override string Color
    {
        get { return color; }
    }
}
class Writer
{
    public void WriteWithPen(Pen pen)
    {
        string input = Console.ReadLine()?.Trim() ?? ""; // 入力でCtrl + Zとかを押されたときには空文字にする
        pen.Write(input);
    }
}
class Program
{
    static void Main()
    {
        Pen redBallPen = new BallPen { ink = new RedInk() };
        Pen blueFountainPen = new FountainPen { ink = new BlueInk() };
        Writer writer = new Writer();
        writer.WriteWithPen(redBallPen);
        writer.WriteWithPen(blueFountainPen);
    }
}
```
これだけを見ても何が良くてこんなコードを書いているのかわからないかもしれませんが, 手続き型のC言語でコードと比較すると良さがわかると思います。
```c
#include <stdio.h>
#include <string.h>
// ペンの種類を列挙
typedef enum {
    PEN_BALL,
    PEN_FOUNTAIN
} PenType;
// インクの種類を列挙
typedef enum {
    INK_RED,
    INK_BLUE
} InkType;
// インクの種類とペンの種類でペンを定義
typedef struct {
    PenType pen;
    InkType ink;
} Pen;
// インクの色にあった文字列を返す
const char* ink_color(InkType ink) {
    // インクの種類によって分岐
    switch (ink) {
        case INK_RED:  return "\x1b[31m";
        case INK_BLUE: return "\x1b[34m";
        default:       return "\x1b[0m";
    }
}
// ペンの種類によって出力
void pen_write(Pen* pen, const char* input) {
    const char* color = ink_color(pen->ink);

    // ペンの種類によって分岐
    switch (pen->pen) {
        case PEN_BALL:
            printf("%s%s\x1b[0m\n", color, input);
            break;

        case PEN_FOUNTAIN:
            printf("%s\x1b[3m%s\x1b[23m\x1b[0m\n", color, input);
            break;
    }
}

void write_with_pen(Pen pen){
    char input[1000];
    scanf("%s1000",input);
    pen_write(&pen, input);
}

int main() {
    Pen red_ball = { PEN_BALL, INK_RED };
    Pen blue_fountain = { PEN_FOUNTAIN, INK_BLUE };
    char input[1000];
    write_with_pen(red_ball);
    write_with_pen(blue_fountain);
}
```
例えば**インク**に**黒**を,**ペン**に**斜体+太字の筆**を追加したいときを考えます。

C言語の場合は`pen_write`の中の条件分岐
```c
// ペンの種類によって分岐
switch (pen->pen) {
    case PEN_BALL:
        printf("%s%s\x1b[0m\n", color, input);
        break;

    case PEN_FOUNTAIN:
        printf("%s\x1b[3m%s\x1b[23m\x1b[0m\n", color, input);
        break;
}
```
に新たに**筆**だった時の分岐を

また`ink_color`の中の条件分岐
```c
// インクの種類によって分岐
switch (ink) {
    case INK_RED:  return "\x1b[31m";
    case INK_BLUE: return "\x1b[34m";
    default:       return "\x1b[0m";
}
```
の中に**黒**だった時の分岐を新たに作る必要があります。

このように,新しいものを追加するときに`pen_write`や`ink_color`といった既存の関数の中身に変更を加える必要があり,**ボールペン**や**青色インク**のように既に動作が保証されているものの動作にかかわる場所を変更することになるので,既存のものを壊してしまう可能性があります。この例は単純なので大きな問題にはなりませんが,規模が大きくなると小さな変更でコード全体が壊れてしまうこともあり,さらに,壊れたときの原因の特定も大変です。

一方、C\#でOOPに基づいて作る場合は

**筆**のクラスをボールペンや万年筆同様に**Pen**という抽象クラスを継承する形で作る。

**黒色インク**のクラスを赤色インクや青色インク同様に**Ink**という抽象クラスを継承して作る。

これだけでよく,既存のコードには一切変更を加える必要がありません。そのため変更に強いと言えます。

さらにC\#では`Write`という振る舞い(関数(メソッド))が`Pen`というデータに紐づいている一方,C言語での`pen_write`は頑張って`pen_`と名前に付けることで関連性を表現していますが,結びつきはC\#のよりも圧倒的に弱いです。

説明が足りなかったかもと思うところの補足

カプセル化は,前回説明した`public`/`private`とかかわりが深く,今回の例ではC\#ので,`RedInk`や`BlueInk`の`color`は取得専用でクラスの外からは`getter`を使っての取得のみが許されていて書き変えや直接の取得はできないようになっていることなどが該当する。これにより予期しない`color`の変更を防ぐことができる。

継承とは, 継承元のクラスにあるふるまいを継承先に実装することを強制することで共通のものとして扱えるようにすることであり,ここでは`Pen`を継承するものに`Write`を実装することを強制することでボールペンも万年筆もペンとして扱えるようにしている。

ポリモーフィズムについては,`pen.Write(input);`だけで条件分岐を使わずにいろんなペンのでの出力ができるようになっていることがいい例だろう
