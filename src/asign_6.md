# 今日の豆知識.6

豆知識.5の続きです

pythonの`=`の本質は参照渡しです。

例えば
```python
x = [1,1,2,3]
y = x
y.append(5)
```
みたいにしたとき`x`,`y`ともに`[1,1,2,3,5]`となります
これは`x`と`y`の割り当てられているメモリ上のアドレスが同じであるため`y`に変更を加えると`x`にもその変更が反映されます

ここで
```python
x = 5
y = x
y = y + 7
```
としたときどうなるかを考えてみましょう。先ほどのリストで`.append(5)`がxに反映されたのであればこれも`y = y + 7`が`x`にも反映されて`x == 12`になってしまっているような気がしてしまうかもしれませんがもちろんそんなことはありません`x == 5`のままです
ではこの違いは何なのでしょうか

違いの正体は 前者の型(list)は**mutable**であり 後者の型(int)は**immutable**であるということです
豆知識.5でも少し**mutable**という言葉は出てきましたが**immutable**はその逆で**不変**です

ここで**int**が不変ってほんと?
だって
```python
x = 5
x = x + 5
```
みたいにしたら`x`の値変わってるじゃん!
って思うかもしれませんが 豆知識.5 で説明した通りこれは値が変化しているのではなく`x`に対応するメモリ上のアドレスが変化しているのです.

一方**list**は値そのものが変化しています

list:
```python
x = [1,1,2,3] # 値([1,1,2,3])にアドレスが割り振られ,xのアドレスがそのアドレスになる
y = x # yのアドレスがxのアドレスになる
y.append(5) # yのアドレスにある値が変化
```
int:
```python
x = 5 # 値(5)にアドレスが割り振られ,xのアドレスがそのアドレスになる
y = x # yのアドレスがxのアドレスになる(ここまでは同じ)
y = y + 7 # 新たに値(12)にアドレスが割り振られ,yのアドレスがそのアドレスになる
```
このように最終的に`x`と`y`のアドレスは前者では一致しているが後者では異なっている

ちなみにC言語やRust言語では`=`の本質は値渡しです
そのため
```rust
let mut x = 5; // (可変)
let mut y = x; // この時点でxとyのアドレスが異なる (可変)
y = y + 5 // yのアドレスは2行目から変化していない
```
のようになっています

さらにちなむと
C#の`class`はPython的参照渡しですが`stract`などは値渡しです

さらにさらにちなむとここで"参照渡し"と呼んでいるものは正確には**参照の値渡し**であって参照渡しの厳密な定義とは少し異なります。
厳密な参照渡しは**alias**つまり別名であってこれに該当するのはC++の
```cpp
int x = 5;
int& y = x;
```
みたいなやつです

この違いとしては
Pythonでは
```python
x = [0,1,2]
y = x
y = [4,5,6]
```
これはxは`[0,1,2]`のまま
C++では
```cpp
std::vector<int> x = {0,1,2};
std::vector<int>& y = x;
y = {4,5,6};
```
これはxは`{4,5,6}`になる
のような違いがあります

RustやCではC++みたいにaliasを作ったりできないので
Rust
```rust
let mut x = [0,1,2];
let mut y = &mut x;
*y = [4,5,6];
```
や
C
```c
int x[3] = {0,1,2};
int (*y)[3] = &x;
int tmp[3] = {4,5,6};
memcpy(*y, tmp, sizeof(tmp));
```
みたいにしてC++のと同じ結果を得る