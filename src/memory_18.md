# 今日の豆知識.18

メモリについて説明します。まず、大前提としてすべてのデータは基本的にメモリ上に記憶されます。そして当然ながらメモリの容量は有限なので、上手く管理する必要があります。そのために様々な方法が考案されてきました。今日はそれらについて説明します。

まずは、ポインタについてです。詳しくは第9回を見返してください。ポインタとはメモリ上のアドレスを記憶する変数です。例えば、
C言語では
```c
int x = 10;
int* ptr_of_x = &x;
```
Rustでは
```rust
let x : i32 = 10;
let ptr_of_x : &i32 = &x;
```
Rustでは後述する所有権による制約があるので厳密に生ポインタではありません。生ポインタは`*mut T`で表されます。
```rust
let mut x: i32 = 10;
let ptr_of_x: *mut i32 = &mut x as *mut i32;
```

メモリは大きく分けてスタック領域とヒープ領域があります。これについての詳細は第10回を見返してください。簡単に説明するとスタック領域は関数に入ったときにメモリが確保されて,関数から抜けるときに自動で解放される領域で,ヒープ領域はメモリの確保と解放をプログラマが直接記述する領域です。

例えば以下のようなプログラムでは
```rust
fn f2(b: i32){
    let c = 30;
    println!("{}", b + c);
}

fn f1(a: i32){
    let b = 20;
    f2(b);
    println!("{}", a + b);
}

fn main() {
    let a = 10;
    f1(a);
}
```
このコードでは`main`関数が呼ばれたときにスタック領域に`a`が確保され,次に`f1`が呼ばれたときにスタック領域に`b`が確保され,次に`f2`が呼ばれたときにスタック領域に`c`が確保されます。そして`f2`が終わると`c`が解放され,`f1`が終わると`b`が解放され,`main`が終わると`a`が解放されます。スタック領域に確保されるのは数値や真偽値のような必要なメモリ領域のサイズが事前にわかっているかつ巨大すぎないものに限られます。また、スタック領域は関数から抜けるときに自動で解放されるので、上の例で`c`を`f1`で使ったりすることはできません。戻り値として値だけを返すことはできますが、この時メモリ上の`c`は解放されていて、`f1`で確保されたスタック領域に`c`のコピーが作られるだけです。そのため、関数間でデータを共有したいときはヒープ領域を使う必要があります。

```rust
fn f2(b: i32)->&i32{
    let c = 30;
    println!("{}", b + c);
    &c
}

fn f1(a: i32){
    let b = 20;
    let c = f2(b);
    println!("{}", a + b + *c);
}

fn main() {
    let a = 10;
    f1(a);
}
```
のようなコードを書くと`c`は`f2`関数内で確保されたスタック領域を指すポインタなので,`f2`関数から抜けた瞬間に`c`が指すメモリ領域は解放されてしまいます。そのため`f1`関数内で`c`を使うとすでに解放されてしまったメモリ領域を参照することになり,プログラムがクラッシュします。

そこでヒープ領域の出番です。ヒープ領域はメモリの確保と解放をプログラマが直接記述する領域です。例えば、
```c
#include<stdio.h>
#include <stdlib.h>

int* f2(){
    int* ptr_of_x = (int*)malloc(sizeof(int));
    *ptr_of_x = 10;
    return ptr_of_x;
}

void f1() {
    int* ptr_of_x = f2();
    int x = *ptr_of_x;
    printf("%d\n",x);
}

int main(){
    f1();
    return 0;
}
```
のようなコードを書くと`f2`関数内で`malloc`によってヒープ領域にメモリが確保され,そのアドレスが`ptr_of_x`に代入されます。そして`f2`関数から抜けてもヒープ領域は解放されないので,`f1`関数内で`ptr_of_x`を使うことができます。しかし、ヒープ上に確保されたメモリはプログラマが明示的に解放しない限り解放されません。そのため、`f1`関数内で`ptr_of_x`を解放しないと`ptr_of_x`がスコープから外れてしまうと(ポインタ自体はスタック領域に確保される)その領域を解放できなくなってしまうので`f1`に以下のように`free(ptr_of_x);`を書いて解放する必要があります。これを忘れるとメモリリークとなってしまいます。また、逆に解放済みのメモリ領域を指すポインタを使い続けてしまうと重大なクラッシュの原因になりえます。
```c
void f1() {
    int* ptr_of_x = f2();
    int x = *ptr_of_x;
    free(ptr_of_x);
    printf("%d\n",x);
}
```

また、動的配列などのサイズが確定していないものもヒープ領域に確保する必要があります。
```c
int main(){
    int n;
    scanf("%d",&n);
    
    int* array = (int*)malloc(sizeof(int)*n); // ヒープ領域にメモリを確保
    
    for(int i = 0; i < n; i++){
        scanf("%d",array+i);
    }
    
    free(array); // メモリを解放
    return 0;
}
```

ヒープは便利な反面,プログラマも人間でありミスをしてメモリリークを起こしてしまったり,解放したメモリ領域を指すポインタを使い続けてしまうといった問題が起こりがちです。

そこで登場するのがガベージコレクション(以降GC)です。詳細なアルゴリズムはさておき,GCは**実行時に**ヒープ領域を走査してどこからも参照されていない領域を自動で解放します。そのため、プログラマはメモリの確保と解放を意識する必要がなくなります。JavaやPythonやC#やJavaScriptなどがGCを採用しています。これらの言語ではポインタを意識することもほとんどないでしょう。

例えばC#で配列を扱うには
```csharp
class Program {
    static void Main() {
        int n = int.TryParse((Console.ReadLine()??throw new Exception("stdin closed")).Trim(), out var sizeResult) ? sizeResult:0;
        
        int[] array = new int[n]; // ここでヒープ領域にメモリが確保される
        
        for (int i = 0; i < n; i++) {
            array[i] = int.TryParse((Console.ReadLine()??throw new Exception("stdin closed")).Trim(), out var inputResult) ? inputResult:0;
        }
    }// ここでarrayがスコープから外れるのでヒープ領域が解放される
}
```
のように書くことができます。このコードでは`array`がスコープから外れると自動で解放されます。エラー処理を書いたので複雑に見えてしまうかもしれませんが、それを除けばC言語で書くよりもずっとシンプルに書くことができています。

GCの欠点としては、**実行時に**ヒープ領域を走査するため、その間プログラムの実行が停止してしまうことです。とはいえ最近のGCはさまざまなアルゴリズムを組み合わせたりアプリケーションと並行して停止時間を短縮しています。

GCは今のところ最も人間に優しい選択肢と言えるでしょう。しかし、リアルタイム性が求められたり、実行リソースが限られていたり、より低レベルの制御が必要な場合はGCは採用できません。そこで登場するのが所有権という概念です。

とりあえずCとC#で書いた動的配列のコードをRustで書き直してみましょう。
```rust
use std::io::stdin;

fn main(){
    let mut input = String::new();
    stdin().read_line(&mut input).expect("stdin closed");
    let n = input.trim().parse::<usize>().unwrap_or(0);
    
    let mut array = vec![0;n]; // ここでヒープ領域にメモリが確保される
    for i in array.iter_mut() {
        input.clear();
        stdin().read_line(&mut input).expect("stdin closed");
        *i = input.trim().parse::<i32>().unwrap_or(0);
    }
} // ここで所有者であるarrayがスコープから外れるのでヒープ領域が解放される
```
見ての通り、GCを採用しているC#とほぼ同じようなコードで書くことができています。
Rustの所有権規則は以下の通りです。
- Rustの各値には、所有者が存在する。
- いかなる時も所有者は一つである。
- 所有者がスコープから外れたら、値は破棄される。

ここで**スコープ**について一応説明しておきます。スコープとは、**要素が有効になるプログラム内の範囲のことです**。

例えば
```rust
fn main(){
    let x = 10; // xが有効になる
    {
        let y = 20; // yが有効になる
        println!("{}",x+y); // xとyが有効なので足し算ができる
    } // yがスコープから外れる
    println!("{}",x); // xは有効だがyはスコープから外れているので使えない
} // xがスコープから外れる
```

のように、`{}`で囲まれた範囲がレキシカルスコープ(lexical scope)です。関数やif文やfor文などでもスコープが作られます。後で説明しますが、借用に関してはスコープが少し違います。

話を戻してなぜ所有権によってメモリの安全を担保できるのかについて説明します。

日本語にすると**所有権**って権利みたいですが、どちらかというと**責任**に近いです。ある値の所有権を持つということは、その値を**解放する責任**を持つということです。したがって値には所有者がただ一つ存在するので、解放を忘れることはなく、また二重解放をしてしまうこともありません。

参照(借用)の規則は以下の通りです
- 任意のタイミングで、一つの可変参照か不変な参照いくつでものどちらかを行える。
- 参照は常に有効でなければならない。

借用先は所有者よりも長いライフタイムを持つことは禁止されているので解放済みのメモリ領域にアクセスしてしまうこともありません。また、可変参照と不変参照を同時に存在させることも規制することでデータ競合を防いでいます。

Rustの所有権/借用はコンパイル時にチェックされるだけで、生成される中間コードレベルではC言語などの生ポインタとほぼ同等であり、実行時のオーバーヘッドはほとんどありません。そのため、GCを採用している言語よりも高速に動作します。コンパイル時に安全が担保されて、実行速度も犠牲にしないという面ではとても魅力的ですが、これも銀の弾丸ではありません。所有権の概念はとても強力ですが、それをプログラマが常に意識する必要があり、習得難易度は高いと言われています(ただ他の言語に無い概念だから慣れてないだけでそんなことは無いと思うけど)。